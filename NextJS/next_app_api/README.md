# Get data from the server
The function to access a server from a page generally uses "Ajax".
A data file is uploaded to the website, and then it is read and displayed by Ajax.
In this way, the display contents can be updated simply by updating the data file.
# fetch API
> fetch is one of the Ajax functions for asynchronous processing.
Basic Writing Style
```js
fetch(URL to access).then(res=> what to do after receiving)
```
### Synchronous processing
This is the method of executing one by one from the beginning.
If there is a time-consuming process, you may not get a response for a while.
> Execute the first one, then the second one, then the third one...
### Asynchronous Processing
This is a way to proceed to the next process even in the middle of execution.
It is a method to proceed to the next process even in the middle of execution.
> When the process is complete, it calls another process that has been prepared in advance to clean up the mess.

## Using the fetch API
1. prepare JSON data
http://localhost:3000/data.json
Create a json file in the public folder.
```js
{
    "message": "This is sample JSON data.",
    "data": [
        {"name": "taro", "mail": "taro@yamada", "age": 39},
        {"name": "hanako", "mail": "hanako@flower", "age": 28}
        {"name": "sachiko", "mail": "sachiko@happy", "age": 17}
    ]
}
```
1. Accessing JSON data with the fetch API
```js
fetch(url)
    .then(res=> res.json())
    .then(res=> setData(res))
```
The `then` method is provided in an object called "Promise", which is returned by `fetch` and `then`.
- Promise
The `then` method is provided by an object called "Promise", which is returned by `fetch` and `then`.
The returned "Promise" can be used to set the work to be done after the asynchronous processing is finished.
- Then method
The argument of `then` is a function.
When the asynchronous processing is over, you can make it so that the function specified in the argument is executed.
### Promise's arrow function returned by fetch(url)
The argument is passed an object called "Response".
It is used to manage the information sent from the server to the client.
The data sent can also be retrieved from here. This time, we will use the method "json" in this Response to get the obtained data converted into an object as json format text.
### Promise's arrow function returned by then(res=> res.json())
In this `then`, `res.json()` is executed, but this json is also executed asynchronously.
After `then(res=> res.json())` is executed, the Promise returned by `res.json()` is returned.
The second then is a further call to then from that Promise.
In this arrow function, the object generated by res.json is returned.
Here, this object is stored in the state with `setData` and used.

3. using the acquired data
After accessing the server and retrieving data and setting it to the data state, create a display using the data state.
- Extract the message property from the data state and display it as `{data.message}`.
```js
<h5 className="mb-4">{data.message}</h5>
```
- Since the data property of the data state contains an array of data, use the `map` method to create a new array based on each element.
    Create a new array based on each element using the `map` method, and display the data using tags such as `<tr>`, `<th>`, and `<td>` in the function.
    The data from the array will be passed to `value`, so each value in the data will be obtained as `value.name`.
```js
{data.data.map((value, key) => (
    <tr key={key}>
        <th>{value.name}</th>.
        <td>{value.mail}</td>
        <td>{value.age}</td>
    </tr>
))}
```
value: The retrieved value
key: Index number

# Using SWR
The fetch API is useful, but if you call it for access, you need to reload the json data manually when it is updated.
The solution to this is **SWR**.
Use it as `useSWR` with your own hooks to fetch values via the `SWR` package network.
### Installing SWR
First, install it in a terminal and then `import` to load the `useSWR` function
```
npm install swr
```
## Use SWR to display json files
1. import
```js
import useSWR from 'swr'
```
2. provide state instead of fetch in the function
```js
const { data } = useSWR('/data.json')
```
3. Calling with ternary operators in JSX
Using the ternary operator
```js
{data ! = undefined ? display content : error display }
```
Concrete example
```js
{ data ! = undefined ? data.message : 'error...' }
```
Creating the table
```js
<table className="table table-dark">
    <thead className="">
        <tr><th>Name</th><th>Mail</th><th>Age</th></tr>
    </thead>
    <tbody>
        { data != undefined ? data.data.map((value, key) => (
        <tr key={key}>
            <th>{value.name}</th>
            <td>{value.mail}</td>
            <td>{value.age}</td>
        </tr>
        )) : <tr><th></th><td>no data.</td><td></td></tr>}
    </tbody>
</table>
```
## Using SWR to get text data
Data in formats other than JSON can be used by specifying the function used for access as an argument.
```js
const { data, err } = useSWR('/data.txt', function)
```
The function that we put as the second argument this time↓
```js
const func = (. .args)=> fetch(. .args).then(res => res.text())
```
`res.text()` returns the data retrieved from Response as text.

## Extracting API data
1. prepare a component for data.
Create data as an array and `export default`.
Export default
```js
export default [.
    {"name": "shiori", "mail": "shiori@com"}
    .
    .
    .
    .
]
```
2. add id parameter to hello API
Rewrite hello.js in the api folder in the pages folder
```js
import apidata from '... /. /components/data'.

export default function handler(req, res) {
  let id = req.query.id
  if (id == undefined) { id = 0 }
  if (id >= apidata.length) { id = 0 }

  res.json(apidata[id])
}
```
3. rewrite the access point and call the data
> http://localhost:3000/api/hello?id=1
The data in the array is specified by `?id=number`.
The part of `?id=1` is called a query parameter, and the passed values are put together in the query property of Request.
### When you want to display several items.
Use `&` to connect them.
> http://localhost:3000/api/hello?id=1&id=2&id=3

## Use the hello API from the page
Using SWR to get data from hello API
Instead of setting the address directly, create the state as follows
1. create a state called `address` to store the address to access. 2.
2. specify `address` as an argument with `useSWR`, so that SWR can call the `data` state when you change the address with `setAddress`.
```js
const [ address, setAddress ] = useState('/api/hello')
const { data, err } = useSWR(address)
```
3. For input fields, set the `onChange` attribute to a function
```js
const onChange = (e) => {
    setAddress('/api/hello?id=' + e.target.value)
}
```
Now the value `/api/hello?id=number` will be set to `address` and SWR will retrieve data using the updated `address`.

## Handle the Id parameter in `[id].js`.
Display `hello?id=1` with a prettier address.
> http://localhost:3000/api/hello/[id number]
Create a hello folder in the api folder and create a `[id].js` file in it.
```js
import apidata from '. /.. /. /components/data'.

export default function handler(req, res) {
    const {
        query: {id}
    } = req
    
    res.json(apidata[id])
}
```
Split assignment in function: `query.id` in `req` is assigned to id in the form of ``{query: [id]}``.
```js
id = req.query.id 

↓

{ query: {id} } = req
```
### Multiple parameters.
We could use `[id].js` to retrieve the id number from the address `/hello/number`, but what if we want to pass multiple parameters by address?
In this case, use the array file name.
> [... Name].js

1. create a new `[...params].js`.
Put the parameter values into the constant `{ query: {params: [id, item]} }`.
Create a new file named `[...params].js`
```js
const {
    query: {params: [id, item]}
} = req
```
In this case, the item in the query assigned from `req` should be the same as the file name.
If the file name is `[. .params].js`, the parameters in `req` must have the same name.
```js
query: {params: [ value ]}
```
2. three states in `index.js`.
- The id and item to be sent as parameters are lumped together and stored in the pref state.
```js
const [ pref, setPref ] = useState({id:0, item:'name'})
```
- The address to access is stored in address.
```js
const [ address, setAddress ] = useState('/api/hello/' + pref.id + '/' + pref.item)
```
- The data to be retrieved by SWR is stored in the state ``data''.
```js
const { data, err } = useSWR(address)
```
Set the functions onChange and onSelect for the input field and the pull-down menu, respectively, and update the state.
Set the values obtained with `e.target.value` to `pref.id` and `pref.item`, and update them with `setPref(pref)`.
The address to access is prepared in another state, so changing it with `setAddress` will update the SWR and make the data up to date.
- Update input fields
```js
const onChange = (e) => {
    pref.id = e.target.value
    setPref(pref)
    setAddress('/api/hello/' + pref.id + '/' + pref.item)
}
```
- Update the pull-down menu
```js
const onSelect = (e)=> {
    pref.item = e.target.value
    setPref(pref)
    setAddress('/api/hello/' + pref.id + '/' + pref.item)
}
```
This is the basis of an application that runs while getting information from a server over the network.


***



# サーバーからデータを取得する
ページからサーバーにアクセスする機能は、一般に「Ajax」を利用する。
Webサイトにデータファイルをアップロードしておき、それをAjaxで読み込んで表示する。
そうすることで、データファイルを更新するだけで表示内容も更新できる。
# fetch API
> fetchはAjax関数のうちの一つで非同期処理。
基本の書き方
```js
fetch(アクセスするURL).then(res=> 受信後の処理)
```
### 同期処理
最初から一つずつ順番に実行していく方法。
毎回処理が終わってから次に進むため、時間のかかる処理があるとしばらく反応が返ってこないこともある
> 一つ目を実行し、これが終わったら二つ目を実行し、それが終わったら三つ目を実行...
### 非同期処理
処理を実行したら、実行の途中でも次の処理に進む方法。
待たずにすぐ次の処理に進むため、時間がかかる処理でも待つことがない
> 他の処理が進められている間、バックグラウンドで実行され、処理が完了したらあらかじめ用意しておいた別の処理を呼び出して後始末をする。

## fetch APIを使う
1. JSONデータの用意
http://localhost:3000/data.json
publicフォルダ内にjsonファイルを作成する
```js
{
    "message": "This is sample JSON data.",
    "data": [
        {"name": "taro", "mail": "taro@yamada", "age": 39},
        {"name": "hanako", "mail": "hanako@flower", "age": 28},
        {"name": "sachiko", "mail": "sachiko@happy", "age": 17}
    ]
}
```
2. fetch APIでJSONデータにアクセスする
```js
fetch(url)
    .then(res=> res.json())
    .then(res=> setData(res))
```
`then`メソッドは、`fetch`や`then`が返す「Promise」というオブジェクトに用意されているもの
- Promise
非同期で実行するメソッドを呼び出した時、「処理が終わった後の挙動を予約する」働きがある。
この返された「Promise」を使って非同期処理が終わった後の作業を設定できる。
- thenメソッド
`then`の引数には関数を指定する。
非同期処理が終わったら、引数に指定した関数を実行するようにできる。
### fetch(url)で返されるPromiseのアロー関数
引数は「Response」というオブジェクトが渡される。
サーバーからクライアントに送られる情報を管理するためのもの
送られてきたデータもここから取り出せる。今回は、このResponseにある「json」というメソッドを使い、得られたデータをjson形式のテキストとしてオブジェクトに変換したものを取得する。
### then(res=> res.json())で返されるPromiseのアロー関数
この`then`の中では、`res.json()`を実行していますが、このjsonも非同期で実行される。
`then(res=> res.json())`は実行後、`res.json()`で返されるPromiseが返される。
そのPromiseからさらにthenを呼び出しているのが二つ目のthen。
このアロー関数では、res.jsonで生成されたオブジェクトが返される。
ここでは、このオブジェクトを`setData`でステートに保管して利用している。

3. 取得したデータの利用
サーバーにアクセスしてデータを取得し、dataステートに設定したらdataステートを使って表示を作成。
- `{data.message}`として、dataステートからmessageプロパティを取り出し表示
```js
<h5 className="mb-4">{data.message}</h5>
```
- dataステートのdataプロパティにデータが配列としてまとめられているので、`map`メソッドを使って各要素を元に新しい配列を作る
    関数内で`<tr>`、`<th>`、`<td>`といったタグを使ってデータの表示を作成
    配列から取り出したデータは`value`に渡されるので、データ内にある各値は`value.name`のように得る
```js
{data.data.map((value, key) => (
    <tr key={key}>
        <th>{value.name}</th>
        <td>{value.mail}</td>
        <td>{value.age}</td>
    </tr>
))}
```
value: 取り出した値
key: インデックス番号

# SWRの利用
fetch APIは便利だが、アクセスに呼び出すなどするとjsonデータが更新された時に手動でリロードする必要がある
これを解決するのが**SWR**
`SWR`パッケージネットワーク経由で値を取得するための独自フックで`useSWR`として使う
### SWRのインストール
まず、ターミナルでインストールした後に`import`して`useSWR`関数をロードする
```
npm install swr
```
## SWRを使ってjsonファイルを表示する
1. インポートする
```js
import useSWR from 'swr'
```
2. 関数の中で fetch の代わりにステートを用意
```js
const { data } = useSWR('/data.json')
```
3. JSX 内で三項演算子を使って呼び出し
三項演算子を使う
```js
{data != undefined ? 表示内容 : エラー表示 }
```
具体例
```js
{ data != undefined ? data.message : 'error...' }
```
テーブルの作成
```js
<table className="table table-dark">
    <thead className="">
        <tr><th>Name</th><th>Mail</th><th>Age</th></tr>
    </thead>
    <tbody>
        { data != undefined ? data.data.map((value, key) => (
        <tr key={key}>
            <th>{value.name}</th>
            <td>{value.mail}</td>
            <td>{value.age}</td>
        </tr>
        )) : <tr><th></th><td>no data.</td><td></td></tr>}
    </tbody>
</table>
```
## SWRを使ってテキストデータを取得する
アクセスに使う関数を引数に指定することでJSON以外のフォーマットのデータを利用できる
```js
const { data, err } = useSWR('/data.txt', function)
```
今回第二引数に入れた関数↓
```js
const func = (...args)=> fetch(...args).then(res => res.text())
```
`res.text()`は、Responseから取得したデータをテキストのまま返す。

## APIデータを取り出す
1. データ用コンポーネントを用意する
データは配列で作成し、`export default`する
```js
export default [
    {"name": "shiori", "mail": "shiori@com"}
    .
    .
    .
    .
]
```
2. hello API に idパラメータを追加する
pagesフォルダ内のapiフォルダにあるhello.jsを書き換え
```js
import apidata from '../../components/data'

export default function handler(req, res) {
  let id = req.query.id
  if (id == undefined) { id = 0 }
  if (id >= apidata.length) { id = 0 }

  res.json(apidata[id])
}
```
3. アクセス先を書き換えてデータを呼び出す
> http://localhost:3000/api/hello?id=1
`?id=番号`とすることで配列の中のデータが指定される
この`?id=1`の部分をクエリーパラメータといい、渡された値はRequestのqueryプロパティにまとめられる。
### いくつか表示させたい時
`&`で繋ぐ
> http://localhost:3000/api/hello?id=1&id=2&id=3

## hello API をページから利用する
SWRを使ってhello APIからデータを取得
直接アドレスを設定するのではなく、以下のような形でステートを作成
1. アクセスするアドレスを保管する`address`というステートを用意
2. `useSWR`で`address`を引数に指定することで`setAddress`でアドレスを変更するとSWRによって`data`ステートを呼び出せる
```js
const [ address, setAddress ] = useState('/api/hello')
const { data, err } = useSWR(address)
```
3. 入力フィールドでは、`onChange`属性に関数を設定する
```js
const onChange = (e) => {
    setAddress('/api/hello?id=' + e.target.value)
}
```
これで`/api/hello?id=番号`という値が`address`に設定され、更新された`address`を使ってSWRはデータを取得するようになる

## `[id].js`でIdパラメータを処理する
`hello?id=1`をもっと綺麗なアドレスで表示する
> http://localhost:3000/api/hello/【ID番号】
apiフォルダの中にhelloフォルダを作ってその中に`[id].js`ファイルを作成する
```js
import apidata from '../../../components/data'

export default function handler(req, res) {
    const {
        query: {id}
    } = req
    
    res.json(apidata[id])
}
```
関数の中で分割代入：`req`の`query.id`が`{query: [id]}`という形でidに代入される。
```js
id = req.query.id 

↓

{ query: {id} } = req
```
### 複数のパラメータの取得
`[id].js`を使って`/hello/番号`というアドレスからid番号を取り出すことはできたが、複数のパラメータをアドレスで渡したい場合はどうするのか。
この場合、配列ファイル名を使用する
> [...名前].js

1. 新しく`[...params].js`という名前のファイルを作成する
`{ query: {params: [id, item]} }`という定数にパラメーターの値を入れる
```js
const {
    query: {params: [id, item]}
} = req
```
この時、`req`から代入されるquery内の項目は、ファイル名と同じである必要がある。
ファイル名が`[...params].js`の時、`req`に入るパラメータは同じ名前である必要がある。
```js
query: {params: [ 値 ]}
```
2. `index.js`に３つのステートを用意
- パラメータとして送信するidとitemは、ひとまとめにしてprefステートに保管。
```js
const [ pref, setPref ] = useState({id:0, item:'name'})
```
- アクセスするアドレスはaddressに保管。
```js
const [ address, setAddress ] = useState('/api/hello/' + pref.id + '/' + pref.item)
```
- SWRで取得するデータはdataというステートに保管。
```js
const { data, err } = useSWR(address)
```
3. 入力フィールドとプルダウンメニューをそれぞれonChangeとonSelectという関数を設定し、ステートの更新を行う
`e.target.value`で得た値を`pref.id`と`pref.item`に設定し、それを`setPref(pref)`で更新する
アクセスするアドレスは別のステートに用意されているので`setAddress`で変更することで、SWRが更新されdataが最新になる
- 入力フィールドの更新
```js
const onChange = (e) => {
    pref.id = e.target.value
    setPref(pref)
    setAddress('/api/hello/' + pref.id + '/' + pref.item)
}
```
- プルダウンメニューの更新
```js
const onSelect = (e)=> {
    pref.item = e.target.value
    setPref(pref)
    setAddress('/api/hello/' + pref.id + '/' + pref.item)
}
```
これがネットワーク経由でサーバーから情報を取得しながら動くアプリの基本